//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Fri Jul 20 14:00:45 EDT 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_put                    O     1
// get_get                        O     8
// RDY_get_get                    O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_put                        I    64 reg
// EN_put_put                     I     1
// EN_get_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFIFO_8_to_1_Byte(CLK,
			  RST_N,

			  put_put,
			  EN_put_put,
			  RDY_put_put,

			  EN_get_get,
			  get_get,
			  RDY_get_get);
  input  CLK;
  input  RST_N;

  // action method put_put
  input  [63 : 0] put_put;
  input  EN_put_put;
  output RDY_put_put;

  // actionvalue method get_get
  input  EN_get_get;
  output [7 : 0] get_get;
  output RDY_get_get;

  // signals for module outputs
  reg [7 : 0] get_get;
  reg RDY_get_get;
  wire RDY_put_put;

  // register dut_id
  reg [2 : 0] dut_id;
  wire [2 : 0] dut_id$D_IN;
  wire dut_id$EN;

  // ports of submodule dut_f_0
  wire [7 : 0] dut_f_0$D_IN, dut_f_0$D_OUT;
  wire dut_f_0$CLR, dut_f_0$DEQ, dut_f_0$EMPTY_N, dut_f_0$ENQ, dut_f_0$FULL_N;

  // ports of submodule dut_f_1
  wire [7 : 0] dut_f_1$D_IN, dut_f_1$D_OUT;
  wire dut_f_1$CLR, dut_f_1$DEQ, dut_f_1$EMPTY_N, dut_f_1$ENQ, dut_f_1$FULL_N;

  // ports of submodule dut_f_2
  wire [7 : 0] dut_f_2$D_IN, dut_f_2$D_OUT;
  wire dut_f_2$CLR, dut_f_2$DEQ, dut_f_2$EMPTY_N, dut_f_2$ENQ, dut_f_2$FULL_N;

  // ports of submodule dut_f_3
  wire [7 : 0] dut_f_3$D_IN, dut_f_3$D_OUT;
  wire dut_f_3$CLR, dut_f_3$DEQ, dut_f_3$EMPTY_N, dut_f_3$ENQ, dut_f_3$FULL_N;

  // ports of submodule dut_f_4
  wire [7 : 0] dut_f_4$D_IN, dut_f_4$D_OUT;
  wire dut_f_4$CLR, dut_f_4$DEQ, dut_f_4$EMPTY_N, dut_f_4$ENQ, dut_f_4$FULL_N;

  // ports of submodule dut_f_5
  wire [7 : 0] dut_f_5$D_IN, dut_f_5$D_OUT;
  wire dut_f_5$CLR, dut_f_5$DEQ, dut_f_5$EMPTY_N, dut_f_5$ENQ, dut_f_5$FULL_N;

  // ports of submodule dut_f_6
  wire [7 : 0] dut_f_6$D_IN, dut_f_6$D_OUT;
  wire dut_f_6$CLR, dut_f_6$DEQ, dut_f_6$EMPTY_N, dut_f_6$ENQ, dut_f_6$FULL_N;

  // ports of submodule dut_f_7
  wire [7 : 0] dut_f_7$D_IN, dut_f_7$D_OUT;
  wire dut_f_7$CLR, dut_f_7$DEQ, dut_f_7$EMPTY_N, dut_f_7$ENQ, dut_f_7$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_get_get,
       CAN_FIRE_put_put,
       WILL_FIRE_get_get,
       WILL_FIRE_put_put;

  // remaining internal signals
  wire dut_f_1_i_notFull__0_AND_dut_f_2_i_notFull__1__ETC___d22;

  // action method put_put
  assign RDY_put_put =
	     dut_f_0$FULL_N &&
	     dut_f_1_i_notFull__0_AND_dut_f_2_i_notFull__1__ETC___d22 ;
  assign CAN_FIRE_put_put =
	     dut_f_0$FULL_N &&
	     dut_f_1_i_notFull__0_AND_dut_f_2_i_notFull__1__ETC___d22 ;
  assign WILL_FIRE_put_put = EN_put_put ;

  // actionvalue method get_get
  always@(dut_id or
	  dut_f_0$D_OUT or
	  dut_f_1$D_OUT or
	  dut_f_2$D_OUT or
	  dut_f_3$D_OUT or
	  dut_f_4$D_OUT or dut_f_5$D_OUT or dut_f_6$D_OUT or dut_f_7$D_OUT)
  begin
    case (dut_id)
      3'd0: get_get = dut_f_0$D_OUT;
      3'd1: get_get = dut_f_1$D_OUT;
      3'd2: get_get = dut_f_2$D_OUT;
      3'd3: get_get = dut_f_3$D_OUT;
      3'd4: get_get = dut_f_4$D_OUT;
      3'd5: get_get = dut_f_5$D_OUT;
      3'd6: get_get = dut_f_6$D_OUT;
      3'd7: get_get = dut_f_7$D_OUT;
    endcase
  end
  always@(dut_id or
	  dut_f_0$EMPTY_N or
	  dut_f_1$EMPTY_N or
	  dut_f_2$EMPTY_N or
	  dut_f_3$EMPTY_N or
	  dut_f_4$EMPTY_N or
	  dut_f_5$EMPTY_N or dut_f_6$EMPTY_N or dut_f_7$EMPTY_N)
  begin
    case (dut_id)
      3'd0: RDY_get_get = dut_f_0$EMPTY_N;
      3'd1: RDY_get_get = dut_f_1$EMPTY_N;
      3'd2: RDY_get_get = dut_f_2$EMPTY_N;
      3'd3: RDY_get_get = dut_f_3$EMPTY_N;
      3'd4: RDY_get_get = dut_f_4$EMPTY_N;
      3'd5: RDY_get_get = dut_f_5$EMPTY_N;
      3'd6: RDY_get_get = dut_f_6$EMPTY_N;
      3'd7: RDY_get_get = dut_f_7$EMPTY_N;
    endcase
  end
  assign CAN_FIRE_get_get = RDY_get_get ;
  assign WILL_FIRE_get_get = EN_get_get ;

  // submodule dut_f_0
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_0(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_0$D_IN),
						  .ENQ(dut_f_0$ENQ),
						  .DEQ(dut_f_0$DEQ),
						  .CLR(dut_f_0$CLR),
						  .D_OUT(dut_f_0$D_OUT),
						  .FULL_N(dut_f_0$FULL_N),
						  .EMPTY_N(dut_f_0$EMPTY_N));

  // submodule dut_f_1
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_1(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_1$D_IN),
						  .ENQ(dut_f_1$ENQ),
						  .DEQ(dut_f_1$DEQ),
						  .CLR(dut_f_1$CLR),
						  .D_OUT(dut_f_1$D_OUT),
						  .FULL_N(dut_f_1$FULL_N),
						  .EMPTY_N(dut_f_1$EMPTY_N));

  // submodule dut_f_2
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_2(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_2$D_IN),
						  .ENQ(dut_f_2$ENQ),
						  .DEQ(dut_f_2$DEQ),
						  .CLR(dut_f_2$CLR),
						  .D_OUT(dut_f_2$D_OUT),
						  .FULL_N(dut_f_2$FULL_N),
						  .EMPTY_N(dut_f_2$EMPTY_N));

  // submodule dut_f_3
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_3(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_3$D_IN),
						  .ENQ(dut_f_3$ENQ),
						  .DEQ(dut_f_3$DEQ),
						  .CLR(dut_f_3$CLR),
						  .D_OUT(dut_f_3$D_OUT),
						  .FULL_N(dut_f_3$FULL_N),
						  .EMPTY_N(dut_f_3$EMPTY_N));

  // submodule dut_f_4
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_4(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_4$D_IN),
						  .ENQ(dut_f_4$ENQ),
						  .DEQ(dut_f_4$DEQ),
						  .CLR(dut_f_4$CLR),
						  .D_OUT(dut_f_4$D_OUT),
						  .FULL_N(dut_f_4$FULL_N),
						  .EMPTY_N(dut_f_4$EMPTY_N));

  // submodule dut_f_5
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_5(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_5$D_IN),
						  .ENQ(dut_f_5$ENQ),
						  .DEQ(dut_f_5$DEQ),
						  .CLR(dut_f_5$CLR),
						  .D_OUT(dut_f_5$D_OUT),
						  .FULL_N(dut_f_5$FULL_N),
						  .EMPTY_N(dut_f_5$EMPTY_N));

  // submodule dut_f_6
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_6(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_6$D_IN),
						  .ENQ(dut_f_6$ENQ),
						  .DEQ(dut_f_6$DEQ),
						  .CLR(dut_f_6$CLR),
						  .D_OUT(dut_f_6$D_OUT),
						  .FULL_N(dut_f_6$FULL_N),
						  .EMPTY_N(dut_f_6$EMPTY_N));

  // submodule dut_f_7
  FIFO2 #(.width(32'd8), .guarded(32'd1)) dut_f_7(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(dut_f_7$D_IN),
						  .ENQ(dut_f_7$ENQ),
						  .DEQ(dut_f_7$DEQ),
						  .CLR(dut_f_7$CLR),
						  .D_OUT(dut_f_7$D_OUT),
						  .FULL_N(dut_f_7$FULL_N),
						  .EMPTY_N(dut_f_7$EMPTY_N));

  // register dut_id
  assign dut_id$D_IN = (dut_id == 3'd7) ? 3'd0 : dut_id + 3'd1 ;
  assign dut_id$EN = EN_get_get ;

  // submodule dut_f_0
  assign dut_f_0$D_IN = put_put[7:0] ;
  assign dut_f_0$ENQ = EN_put_put ;
  assign dut_f_0$DEQ = EN_get_get && dut_id == 3'd0 ;
  assign dut_f_0$CLR = 1'b0 ;

  // submodule dut_f_1
  assign dut_f_1$D_IN = put_put[15:8] ;
  assign dut_f_1$ENQ = EN_put_put ;
  assign dut_f_1$DEQ = EN_get_get && dut_id == 3'd1 ;
  assign dut_f_1$CLR = 1'b0 ;

  // submodule dut_f_2
  assign dut_f_2$D_IN = put_put[23:16] ;
  assign dut_f_2$ENQ = EN_put_put ;
  assign dut_f_2$DEQ = EN_get_get && dut_id == 3'd2 ;
  assign dut_f_2$CLR = 1'b0 ;

  // submodule dut_f_3
  assign dut_f_3$D_IN = put_put[31:24] ;
  assign dut_f_3$ENQ = EN_put_put ;
  assign dut_f_3$DEQ = EN_get_get && dut_id == 3'd3 ;
  assign dut_f_3$CLR = 1'b0 ;

  // submodule dut_f_4
  assign dut_f_4$D_IN = put_put[39:32] ;
  assign dut_f_4$ENQ = EN_put_put ;
  assign dut_f_4$DEQ = EN_get_get && dut_id == 3'd4 ;
  assign dut_f_4$CLR = 1'b0 ;

  // submodule dut_f_5
  assign dut_f_5$D_IN = put_put[47:40] ;
  assign dut_f_5$ENQ = EN_put_put ;
  assign dut_f_5$DEQ = EN_get_get && dut_id == 3'd5 ;
  assign dut_f_5$CLR = 1'b0 ;

  // submodule dut_f_6
  assign dut_f_6$D_IN = put_put[55:48] ;
  assign dut_f_6$ENQ = EN_put_put ;
  assign dut_f_6$DEQ = EN_get_get && dut_id == 3'd6 ;
  assign dut_f_6$CLR = 1'b0 ;

  // submodule dut_f_7
  assign dut_f_7$D_IN = put_put[63:56] ;
  assign dut_f_7$ENQ = EN_put_put ;
  assign dut_f_7$DEQ = EN_get_get && dut_id == 3'd7 ;
  assign dut_f_7$CLR = 1'b0 ;

  // remaining internal signals
  assign dut_f_1_i_notFull__0_AND_dut_f_2_i_notFull__1__ETC___d22 =
	     dut_f_1$FULL_N && dut_f_2$FULL_N && dut_f_3$FULL_N &&
	     dut_f_4$FULL_N &&
	     dut_f_5$FULL_N &&
	     dut_f_6$FULL_N &&
	     dut_f_7$FULL_N ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        dut_id <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (dut_id$EN) dut_id <= `BSV_ASSIGNMENT_DELAY dut_id$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    dut_id = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFIFO_8_to_1_Byte


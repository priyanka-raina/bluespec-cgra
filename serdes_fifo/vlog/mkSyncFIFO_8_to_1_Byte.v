//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Fri Jul 20 14:00:45 EDT 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_put_put                    O     1
// get_get                        O     8
// RDY_get_get                    O     1
// CLK_io_clk                     I     1 clock
// RST_N_io_rst_n                 I     1 reset
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_put                        I    64
// EN_put_put                     I     1
// EN_get_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSyncFIFO_8_to_1_Byte(CLK_io_clk,
			      RST_N_io_rst_n,
			      CLK,
			      RST_N,

			      put_put,
			      EN_put_put,
			      RDY_put_put,

			      EN_get_get,
			      get_get,
			      RDY_get_get);
  input  CLK_io_clk;
  input  RST_N_io_rst_n;
  input  CLK;
  input  RST_N;

  // action method put_put
  input  [63 : 0] put_put;
  input  EN_put_put;
  output RDY_put_put;

  // actionvalue method get_get
  input  EN_get_get;
  output [7 : 0] get_get;
  output RDY_get_get;

  // signals for module outputs
  reg [7 : 0] get_get;
  reg RDY_get_get;
  wire RDY_put_put;

  // register dut_id
  reg [2 : 0] dut_id;
  wire [2 : 0] dut_id$D_IN;
  wire dut_id$EN;

  // ports of submodule dut_f_0
  wire [7 : 0] dut_f_0$dD_OUT, dut_f_0$sD_IN;
  wire dut_f_0$dDEQ, dut_f_0$dEMPTY_N, dut_f_0$sENQ, dut_f_0$sFULL_N;

  // ports of submodule dut_f_1
  wire [7 : 0] dut_f_1$dD_OUT, dut_f_1$sD_IN;
  wire dut_f_1$dDEQ, dut_f_1$dEMPTY_N, dut_f_1$sENQ, dut_f_1$sFULL_N;

  // ports of submodule dut_f_2
  wire [7 : 0] dut_f_2$dD_OUT, dut_f_2$sD_IN;
  wire dut_f_2$dDEQ, dut_f_2$dEMPTY_N, dut_f_2$sENQ, dut_f_2$sFULL_N;

  // ports of submodule dut_f_3
  wire [7 : 0] dut_f_3$dD_OUT, dut_f_3$sD_IN;
  wire dut_f_3$dDEQ, dut_f_3$dEMPTY_N, dut_f_3$sENQ, dut_f_3$sFULL_N;

  // ports of submodule dut_f_4
  wire [7 : 0] dut_f_4$dD_OUT, dut_f_4$sD_IN;
  wire dut_f_4$dDEQ, dut_f_4$dEMPTY_N, dut_f_4$sENQ, dut_f_4$sFULL_N;

  // ports of submodule dut_f_5
  wire [7 : 0] dut_f_5$dD_OUT, dut_f_5$sD_IN;
  wire dut_f_5$dDEQ, dut_f_5$dEMPTY_N, dut_f_5$sENQ, dut_f_5$sFULL_N;

  // ports of submodule dut_f_6
  wire [7 : 0] dut_f_6$dD_OUT, dut_f_6$sD_IN;
  wire dut_f_6$dDEQ, dut_f_6$dEMPTY_N, dut_f_6$sENQ, dut_f_6$sFULL_N;

  // ports of submodule dut_f_7
  wire [7 : 0] dut_f_7$dD_OUT, dut_f_7$sD_IN;
  wire dut_f_7$dDEQ, dut_f_7$dEMPTY_N, dut_f_7$sENQ, dut_f_7$sFULL_N;

  // rule scheduling signals
  wire CAN_FIRE_get_get,
       CAN_FIRE_put_put,
       WILL_FIRE_get_get,
       WILL_FIRE_put_put;

  // remaining internal signals
  wire dut_f_1_RDY_enq__0_AND_dut_f_2_RDY_enq__1_AND__ETC___d22;

  // action method put_put
  assign RDY_put_put =
	     dut_f_0$sFULL_N &&
	     dut_f_1_RDY_enq__0_AND_dut_f_2_RDY_enq__1_AND__ETC___d22 ;
  assign CAN_FIRE_put_put =
	     dut_f_0$sFULL_N &&
	     dut_f_1_RDY_enq__0_AND_dut_f_2_RDY_enq__1_AND__ETC___d22 ;
  assign WILL_FIRE_put_put = EN_put_put ;

  // actionvalue method get_get
  always@(dut_id or
	  dut_f_0$dD_OUT or
	  dut_f_1$dD_OUT or
	  dut_f_2$dD_OUT or
	  dut_f_3$dD_OUT or
	  dut_f_4$dD_OUT or
	  dut_f_5$dD_OUT or dut_f_6$dD_OUT or dut_f_7$dD_OUT)
  begin
    case (dut_id)
      3'd0: get_get = dut_f_0$dD_OUT;
      3'd1: get_get = dut_f_1$dD_OUT;
      3'd2: get_get = dut_f_2$dD_OUT;
      3'd3: get_get = dut_f_3$dD_OUT;
      3'd4: get_get = dut_f_4$dD_OUT;
      3'd5: get_get = dut_f_5$dD_OUT;
      3'd6: get_get = dut_f_6$dD_OUT;
      3'd7: get_get = dut_f_7$dD_OUT;
    endcase
  end
  always@(dut_id or
	  dut_f_0$dEMPTY_N or
	  dut_f_1$dEMPTY_N or
	  dut_f_2$dEMPTY_N or
	  dut_f_3$dEMPTY_N or
	  dut_f_4$dEMPTY_N or
	  dut_f_5$dEMPTY_N or dut_f_6$dEMPTY_N or dut_f_7$dEMPTY_N)
  begin
    case (dut_id)
      3'd0: RDY_get_get = dut_f_0$dEMPTY_N;
      3'd1: RDY_get_get = dut_f_1$dEMPTY_N;
      3'd2: RDY_get_get = dut_f_2$dEMPTY_N;
      3'd3: RDY_get_get = dut_f_3$dEMPTY_N;
      3'd4: RDY_get_get = dut_f_4$dEMPTY_N;
      3'd5: RDY_get_get = dut_f_5$dEMPTY_N;
      3'd6: RDY_get_get = dut_f_6$dEMPTY_N;
      3'd7: RDY_get_get = dut_f_7$dEMPTY_N;
    endcase
  end
  assign CAN_FIRE_get_get = RDY_get_get ;
  assign WILL_FIRE_get_get = EN_get_get ;

  // submodule dut_f_0
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_0(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_0$sD_IN),
					.sENQ(dut_f_0$sENQ),
					.dDEQ(dut_f_0$dDEQ),
					.sFULL_N(dut_f_0$sFULL_N),
					.dEMPTY_N(dut_f_0$dEMPTY_N),
					.dD_OUT(dut_f_0$dD_OUT));

  // submodule dut_f_1
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_1(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_1$sD_IN),
					.sENQ(dut_f_1$sENQ),
					.dDEQ(dut_f_1$dDEQ),
					.sFULL_N(dut_f_1$sFULL_N),
					.dEMPTY_N(dut_f_1$dEMPTY_N),
					.dD_OUT(dut_f_1$dD_OUT));

  // submodule dut_f_2
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_2(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_2$sD_IN),
					.sENQ(dut_f_2$sENQ),
					.dDEQ(dut_f_2$dDEQ),
					.sFULL_N(dut_f_2$sFULL_N),
					.dEMPTY_N(dut_f_2$dEMPTY_N),
					.dD_OUT(dut_f_2$dD_OUT));

  // submodule dut_f_3
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_3(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_3$sD_IN),
					.sENQ(dut_f_3$sENQ),
					.dDEQ(dut_f_3$dDEQ),
					.sFULL_N(dut_f_3$sFULL_N),
					.dEMPTY_N(dut_f_3$dEMPTY_N),
					.dD_OUT(dut_f_3$dD_OUT));

  // submodule dut_f_4
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_4(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_4$sD_IN),
					.sENQ(dut_f_4$sENQ),
					.dDEQ(dut_f_4$dDEQ),
					.sFULL_N(dut_f_4$sFULL_N),
					.dEMPTY_N(dut_f_4$dEMPTY_N),
					.dD_OUT(dut_f_4$dD_OUT));

  // submodule dut_f_5
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_5(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_5$sD_IN),
					.sENQ(dut_f_5$sENQ),
					.dDEQ(dut_f_5$dDEQ),
					.sFULL_N(dut_f_5$sFULL_N),
					.dEMPTY_N(dut_f_5$dEMPTY_N),
					.dD_OUT(dut_f_5$dD_OUT));

  // submodule dut_f_6
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_6(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_6$sD_IN),
					.sENQ(dut_f_6$sENQ),
					.dDEQ(dut_f_6$dDEQ),
					.sFULL_N(dut_f_6$sFULL_N),
					.dEMPTY_N(dut_f_6$dEMPTY_N),
					.dD_OUT(dut_f_6$dD_OUT));

  // submodule dut_f_7
  SyncFIFO #(.dataWidth(32'd8),
	     .depth(32'd2),
	     .indxWidth(32'd1)) dut_f_7(.sCLK(CLK),
					.dCLK(CLK_io_clk),
					.sRST(RST_N),
					.sD_IN(dut_f_7$sD_IN),
					.sENQ(dut_f_7$sENQ),
					.dDEQ(dut_f_7$dDEQ),
					.sFULL_N(dut_f_7$sFULL_N),
					.dEMPTY_N(dut_f_7$dEMPTY_N),
					.dD_OUT(dut_f_7$dD_OUT));

  // register dut_id
  assign dut_id$D_IN = (dut_id == 3'd7) ? 3'd0 : dut_id + 3'd1 ;
  assign dut_id$EN = EN_get_get ;

  // submodule dut_f_0
  assign dut_f_0$sD_IN = put_put[7:0] ;
  assign dut_f_0$sENQ = EN_put_put ;
  assign dut_f_0$dDEQ = EN_get_get && dut_id == 3'd0 ;

  // submodule dut_f_1
  assign dut_f_1$sD_IN = put_put[15:8] ;
  assign dut_f_1$sENQ = EN_put_put ;
  assign dut_f_1$dDEQ = EN_get_get && dut_id == 3'd1 ;

  // submodule dut_f_2
  assign dut_f_2$sD_IN = put_put[23:16] ;
  assign dut_f_2$sENQ = EN_put_put ;
  assign dut_f_2$dDEQ = EN_get_get && dut_id == 3'd2 ;

  // submodule dut_f_3
  assign dut_f_3$sD_IN = put_put[31:24] ;
  assign dut_f_3$sENQ = EN_put_put ;
  assign dut_f_3$dDEQ = EN_get_get && dut_id == 3'd3 ;

  // submodule dut_f_4
  assign dut_f_4$sD_IN = put_put[39:32] ;
  assign dut_f_4$sENQ = EN_put_put ;
  assign dut_f_4$dDEQ = EN_get_get && dut_id == 3'd4 ;

  // submodule dut_f_5
  assign dut_f_5$sD_IN = put_put[47:40] ;
  assign dut_f_5$sENQ = EN_put_put ;
  assign dut_f_5$dDEQ = EN_get_get && dut_id == 3'd5 ;

  // submodule dut_f_6
  assign dut_f_6$sD_IN = put_put[55:48] ;
  assign dut_f_6$sENQ = EN_put_put ;
  assign dut_f_6$dDEQ = EN_get_get && dut_id == 3'd6 ;

  // submodule dut_f_7
  assign dut_f_7$sD_IN = put_put[63:56] ;
  assign dut_f_7$sENQ = EN_put_put ;
  assign dut_f_7$dDEQ = EN_get_get && dut_id == 3'd7 ;

  // remaining internal signals
  assign dut_f_1_RDY_enq__0_AND_dut_f_2_RDY_enq__1_AND__ETC___d22 =
	     dut_f_1$sFULL_N && dut_f_2$sFULL_N && dut_f_3$sFULL_N &&
	     dut_f_4$sFULL_N &&
	     dut_f_5$sFULL_N &&
	     dut_f_6$sFULL_N &&
	     dut_f_7$sFULL_N ;

  // handling of inlined registers

  always@(posedge CLK_io_clk)
  begin
    if (RST_N_io_rst_n == `BSV_RESET_VALUE)
      begin
        dut_id <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (dut_id$EN) dut_id <= `BSV_ASSIGNMENT_DELAY dut_id$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    dut_id = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSyncFIFO_8_to_1_Byte

